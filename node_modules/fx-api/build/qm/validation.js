"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.validate = exports.getValidationFunction = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs-extra"));
const jsonschema = tslib_1.__importStar(require("jsonschema"));
function getValidationFunction(validation, outputs, remoteFuncValidator) {
    return async function (input) {
        return await validate(validation, input, outputs, remoteFuncValidator);
    };
}
exports.getValidationFunction = getValidationFunction;
async function validate(validation, valueToValidate, inputs, remoteFuncValidator) {
    //RemoteFuncValidation
    {
        const funcValidation = validation;
        if (funcValidation.method && remoteFuncValidator) {
            funcValidation.params = valueToValidate;
            const res = await remoteFuncValidator(funcValidation, inputs);
            if (res.isOk()) {
                return res.value;
            }
            else {
                return undefined; // when callFunc failed, skip the validation
            }
        }
    }
    {
        //LocalFuncValidation
        const localFuncValidation = validation;
        if (localFuncValidation.validFunc) {
            const res = await localFuncValidation.validFunc(valueToValidate, inputs);
            return res;
        }
    }
    {
        //FileValidation
        const fileValidation = validation;
        if (fileValidation.exists !== undefined) {
            const path = valueToValidate;
            if (!path) {
                return `path should not be empty!`;
            }
            const exists = await fs.pathExists(path);
            if (exists !== fileValidation.exists) {
                return `path(${path}) existence should be ${fileValidation.exists}`;
            }
            return undefined;
        }
    }
    {
        // StringValidation
        const stringValidation = validation;
        const strToValidate = valueToValidate;
        if (typeof strToValidate === "string") {
            const schema = {};
            if (stringValidation.equals && typeof stringValidation.equals === "string")
                schema.const = stringValidation.equals;
            if (stringValidation.enum &&
                stringValidation.enum.length > 0 &&
                typeof stringValidation.enum[0] === "string")
                schema.enum = stringValidation.enum;
            if (stringValidation.minLength)
                schema.minLength = stringValidation.minLength;
            if (stringValidation.maxLength)
                schema.maxLength = stringValidation.maxLength;
            if (stringValidation.pattern)
                schema.pattern = stringValidation.pattern;
            if (Object.keys(schema).length > 0) {
                const validateResult = jsonschema.validate(valueToValidate, schema);
                if (validateResult.errors && validateResult.errors.length > 0) {
                    return `'${strToValidate}' ${validateResult.errors[0].message}`;
                }
            }
            if (stringValidation.startsWith) {
                if (!strToValidate.startsWith(stringValidation.startsWith)) {
                    return `'${strToValidate}' does not meet startsWith:'${stringValidation.startsWith}'`;
                }
            }
            if (stringValidation.endsWith) {
                if (!strToValidate.endsWith(stringValidation.endsWith)) {
                    return `'${strToValidate}' does not meet endsWith:'${stringValidation.endsWith}'`;
                }
            }
            if (stringValidation.includes && typeof strToValidate === "string") {
                if (!strToValidate.includes(stringValidation.includes)) {
                    return `'${strToValidate}' does not meet includes:'${stringValidation.includes}'`;
                }
            }
        }
    }
    //NumberValidation
    {
        const numberValidation = validation;
        const numberToValidate = Number(valueToValidate);
        const schema = {};
        if (numberValidation.equals && typeof numberValidation.equals === "number")
            schema.const = numberValidation.equals;
        if (numberValidation.multipleOf)
            schema.multipleOf = numberValidation.multipleOf;
        if (numberValidation.maximum)
            schema.maximum = numberValidation.maximum;
        if (numberValidation.exclusiveMaximum)
            schema.exclusiveMaximum = numberValidation.exclusiveMaximum;
        if (numberValidation.minimum)
            schema.minimum = numberValidation.minimum;
        if (numberValidation.exclusiveMinimum)
            schema.exclusiveMinimum = numberValidation.exclusiveMinimum;
        if (numberValidation.enum &&
            numberValidation.enum.length > 0 &&
            typeof numberValidation.enum[0] === "number")
            schema.enum = numberValidation.enum;
        if (Object.keys(schema).length > 0) {
            const validateResult = jsonschema.validate(numberToValidate, schema);
            if (validateResult.errors && validateResult.errors.length > 0) {
                return `'${numberToValidate}' ${validateResult.errors[0].message}`;
            }
        }
    }
    //StringArrayValidation
    {
        const stringArrayValidation = validation;
        const arrayToValidate = valueToValidate;
        if (arrayToValidate instanceof Array) {
            const schema = {};
            if (stringArrayValidation.maxItems)
                schema.maxItems = stringArrayValidation.maxItems;
            if (stringArrayValidation.minItems)
                schema.minItems = stringArrayValidation.minItems;
            if (stringArrayValidation.uniqueItems)
                schema.uniqueItems = stringArrayValidation.uniqueItems;
            if (Object.keys(schema).length > 0) {
                const validateResult = jsonschema.validate(arrayToValidate, schema);
                if (validateResult.errors && validateResult.errors.length > 0) {
                    return `'${arrayToValidate}' ${validateResult.errors[0].message}`;
                }
            }
            if (stringArrayValidation.equals && stringArrayValidation.equals instanceof Array) {
                stringArrayValidation.enum = stringArrayValidation.equals;
                stringArrayValidation.containsAll = stringArrayValidation.equals;
            }
            if (stringArrayValidation.enum) {
                for (const item of arrayToValidate) {
                    if (!stringArrayValidation.enum.includes(item)) {
                        return `'${arrayToValidate}' does not meet enum:'${stringArrayValidation.enum}'`;
                    }
                }
            }
            if (stringArrayValidation.contains) {
                if (!arrayToValidate.includes(stringArrayValidation.contains)) {
                    return `'${arrayToValidate}' does not meet contains:'${stringArrayValidation.contains}'`;
                }
            }
            if (stringArrayValidation.containsAll) {
                const containsAll = stringArrayValidation.containsAll;
                if (containsAll.length > 0) {
                    for (const i of containsAll) {
                        if (!arrayToValidate.includes(i)) {
                            return `'${arrayToValidate}' does not meet containsAll:'${containsAll}'`;
                        }
                    }
                }
            }
            if (stringArrayValidation.containsAny) {
                const containsAny = stringArrayValidation.containsAny;
                if (containsAny.length > 0) {
                    // let array = valueToValidate as string[];
                    let found = false;
                    for (const i of containsAny) {
                        if (arrayToValidate.includes(i)) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        return `'${arrayToValidate}' does not meet containsAny:'${containsAny}'`;
                    }
                }
            }
        }
    }
    return undefined;
}
exports.validate = validate;
//# sourceMappingURL=validation.js.map