"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.traverse = exports.getCallFuncValue = exports.getSingleOption = exports.loadOptions = exports.isAutoSkipSelect = void 0;
const question_1 = require("./question");
const validation_1 = require("./validation");
const config_1 = require("../config");
const ui_1 = require("./ui");
const error_1 = require("../error");
async function getRealValue(parentValue, defaultValue, inputs, remoteFuncExecutor) {
    let output = defaultValue;
    if (typeof defaultValue === "string") {
        const defstr = defaultValue;
        if (defstr === "$parent") {
            output = parentValue;
        }
        else if (defstr.startsWith("$parent.") && parentValue instanceof Object) {
            const property = defstr.substr(8);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            output = parentValue[property];
        }
    }
    else {
        output = await getCallFuncValue(inputs, false, defaultValue, remoteFuncExecutor);
    }
    return output;
}
function isAutoSkipSelect(q) {
    if (q.type === question_1.NodeType.singleSelect || q.type === question_1.NodeType.multiSelect) {
        const select = q;
        const options = select.option;
        if (select.skipSingleOption && select.option instanceof Array && options.length === 1) {
            return true;
        }
    }
    return false;
}
exports.isAutoSkipSelect = isAutoSkipSelect;
async function loadOptions(q, inputs, remoteFuncExecutor) {
    if (q.type === question_1.NodeType.singleSelect || q.type === question_1.NodeType.multiSelect) {
        const selectQuestion = q;
        let option = [];
        if (selectQuestion.option instanceof Array) {
            //StaticOption
            option = selectQuestion.option;
        }
        else {
            option = await getCallFuncValue(inputs, false, selectQuestion.option, remoteFuncExecutor);
        }
        if (selectQuestion.skipSingleOption && option.length === 1) {
            return { autoSkip: true, options: option };
        }
        else {
            return { autoSkip: false, options: option };
        }
    }
    else {
        return { autoSkip: false };
    }
}
exports.loadOptions = loadOptions;
function getSingleOption(q, option) {
    if (!option)
        option = q.option;
    const optionIsString = typeof option[0] === "string";
    let returnResult;
    if (q.returnObject) {
        returnResult = optionIsString ? { id: option[0] } : option[0];
    }
    else {
        returnResult = optionIsString ? option[0] : option[0].id;
    }
    if (q.type === question_1.NodeType.singleSelect) {
        return returnResult;
    }
    else {
        return [returnResult];
    }
}
exports.getSingleOption = getSingleOption;
async function getCallFuncValue(inputs, throwError, raw, remoteFuncExecutor) {
    if (raw) {
        if (raw.method) {
            if (remoteFuncExecutor) {
                const res = await remoteFuncExecutor(raw, inputs);
                if (res.isOk()) {
                    return res.value;
                }
                else if (throwError) {
                    throw res.error;
                }
            }
        }
        else if (typeof raw === "function") {
            return await raw(inputs);
        }
    }
    return raw;
}
exports.getCallFuncValue = getCallFuncValue;
/**
 * ask question when visiting the question tree
 * @param question
 * @param core
 * @param inputs
 */
const questionVisitor = async function (question, parentValue, ui, backButton, inputs, remoteFuncExecutor, step, totalSteps) {
    //FunctionCallQuestion
    if (question.type === question_1.NodeType.func) {
        if (remoteFuncExecutor) {
            const res = await remoteFuncExecutor(question, inputs);
            if (res.isOk()) {
                return { type: ui_1.InputResultType.sucess, result: res.value };
            }
            else {
                return { type: ui_1.InputResultType.error, error: res.error };
            }
        }
    }
    else if (question.type === question_1.NodeType.localFunc) {
        const res = await question.func(inputs);
        return { type: ui_1.InputResultType.sucess, result: res };
    }
    else {
        const title = question.title || question.name;
        const defaultValue = question.value ? question.value : await getRealValue(parentValue, question.default, inputs, remoteFuncExecutor);
        if (question.type === question_1.NodeType.text || question.type === question_1.NodeType.password || question.type === question_1.NodeType.number) {
            const inputQuestion = question;
            const validationFunc = inputQuestion.validation ? validation_1.getValidationFunction(inputQuestion.validation, inputs, remoteFuncExecutor) : undefined;
            const placeholder = await getCallFuncValue(inputs, false, inputQuestion.placeholder, remoteFuncExecutor);
            const prompt = await getCallFuncValue(inputs, false, inputQuestion.prompt, remoteFuncExecutor);
            return await ui.showInputBox({
                title: title,
                password: !!(question.type === question_1.NodeType.password),
                defaultValue: defaultValue,
                placeholder: placeholder,
                prompt: prompt,
                validation: validationFunc,
                backButton: backButton,
                number: !!(question.type === question_1.NodeType.number),
                // step: step,
                // totalSteps: totalSteps
            });
        }
        else if (question.type === question_1.NodeType.singleSelect || question.type === question_1.NodeType.multiSelect) {
            const selectQuestion = question;
            const res = await loadOptions(selectQuestion, inputs, remoteFuncExecutor);
            if (!res.options || res.options.length === 0) {
                return {
                    type: ui_1.InputResultType.error,
                    error: error_1.returnSystemError(new Error("Select option is empty!"), "API", "EmptySelectOption")
                };
            }
            // Skip single/mulitple option select
            if (res.autoSkip === true) {
                const returnResult = getSingleOption(selectQuestion, res.options);
                return {
                    type: ui_1.InputResultType.pass,
                    result: returnResult
                };
            }
            const placeholder = await getCallFuncValue(inputs, false, selectQuestion.placeholder, remoteFuncExecutor);
            const mq = selectQuestion;
            const validationFunc = mq.validation ? validation_1.getValidationFunction(mq.validation, inputs, remoteFuncExecutor) : undefined;
            const prompt = await getCallFuncValue(inputs, false, mq.prompt, remoteFuncExecutor);
            return await ui.showQuickPick({
                title: title,
                items: res.options,
                canSelectMany: !!(question.type === question_1.NodeType.multiSelect),
                returnObject: selectQuestion.returnObject,
                defaultValue: defaultValue,
                placeholder: placeholder,
                backButton: backButton,
                onDidChangeSelection: question.type === question_1.NodeType.multiSelect ? mq.onDidChangeSelection : undefined,
                validation: validationFunc,
                prompt: prompt
                // step: step,
                // totalSteps: totalSteps
            });
        }
        else if (question.type === question_1.NodeType.folder) {
            const fileQuestion = question;
            const validationFunc = fileQuestion.validation ? validation_1.getValidationFunction(fileQuestion.validation, inputs, remoteFuncExecutor) : undefined;
            return await ui.showOpenDialog({
                defaultUri: defaultValue,
                canSelectFiles: false,
                canSelectFolders: true,
                canSelectMany: false,
                title: title,
                validation: validationFunc,
                backButton: backButton,
                // step: step,
                // totalSteps: totalSteps
            });
        }
    }
    return {
        type: ui_1.InputResultType.error,
        error: error_1.returnUserError(new Error(`Unsupported question node type:${question.type}`), "API.qm", "UnsupportedNodeType")
    };
};
async function traverse(root, inputs, ui, remoteFuncExecutor) {
    const stack = [];
    const history = [];
    let firstQuestion;
    stack.push(root);
    let step = 0;
    let totalSteps = 1;
    const parentMap = new Map();
    while (stack.length > 0) {
        const curr = stack.pop();
        if (!curr)
            continue;
        const parent = parentMap.get(curr);
        let parentValue = parent && parent.data.type !== question_1.NodeType.group ? parent.data.value : undefined;
        if (curr.condition) {
            /// if parent node is single select node and return OptionItem as value, then the parentValue is it's id
            if (parent && parent.data.type === question_1.NodeType.singleSelect) {
                const sq = parent.data;
                if (sq.returnObject) {
                    parentValue = sq.value.id;
                }
            }
            const valueToValidate = curr.condition.target ? await getRealValue(parentValue, curr.condition.target, inputs, remoteFuncExecutor) : parentValue;
            if (valueToValidate) {
                const validRes = await validation_1.validate(curr.condition, valueToValidate, inputs, remoteFuncExecutor);
                if (validRes !== undefined) {
                    continue;
                }
            }
        }
        //visit
        if (curr.data.type !== question_1.NodeType.group) {
            const question = curr.data;
            if (!firstQuestion)
                firstQuestion = question;
            ++step;
            totalSteps = step + stack.length;
            const inputResult = await questionVisitor(question, parentValue, ui, question !== firstQuestion, inputs, remoteFuncExecutor, step, totalSteps);
            if (inputResult.type === ui_1.InputResultType.back) {
                //go back
                if (curr.children) {
                    while (stack.length > 0) {
                        const tmp = stack[stack.length - 1];
                        if (curr.children.includes(tmp)) {
                            stack.pop();
                        }
                        else {
                            break;
                        }
                    }
                }
                stack.push(curr);
                --step;
                // find the previoud input that is neither group nor func nor single option select
                let found = false;
                while (history.length > 0) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const last = history.pop();
                    if (last.children) {
                        while (stack.length > 0) {
                            const tmp = stack[stack.length - 1];
                            if (last.children.includes(tmp)) {
                                stack.pop();
                            }
                            else {
                                break;
                            }
                        }
                    }
                    stack.push(last);
                    --step;
                    let autoSkip = false;
                    if (last.data.type === question_1.NodeType.singleSelect || last.data.type === question_1.NodeType.multiSelect) {
                        const loadOptionRes = await loadOptions(last.data, inputs, remoteFuncExecutor);
                        autoSkip = loadOptionRes.autoSkip;
                    }
                    if (last.data.type !== question_1.NodeType.group &&
                        last.data.type !== question_1.NodeType.func &&
                        !autoSkip) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    // no node to back
                    return { type: ui_1.InputResultType.back };
                }
                continue; //ignore the following steps
            }
            else if (inputResult.type === ui_1.InputResultType.error ||
                inputResult.type === ui_1.InputResultType.cancel) {
                //cancel
                return inputResult;
            } //continue
            else {
                //success or pass
                question.value = inputResult.result;
                if (inputs instanceof config_1.ConfigMap) {
                    inputs.set(question.name, question.value);
                }
                else {
                    inputs[question.name] = question.value;
                }
            }
        }
        history.push(curr);
        if (curr.children) {
            for (let i = curr.children.length - 1; i >= 0; --i) {
                const child = curr.children[i];
                if (!child)
                    continue;
                parentMap.set(child, curr);
                stack.push(child);
                // if(child.data.type === NodeType.func || child.data.type === NodeType.group) //ignore non-input node
                //   continue;
                // if (child.condition) {  //ignore node to skip
                //   let currValue = curr.data.type !== NodeType.group ? curr.data.value : undefined;
                //   if (curr.data.type === NodeType.singleSelect) {
                //     const csq:SingleSelectQuestion = curr.data;
                //     if (csq.returnObject) {
                //       currValue = (csq.value as OptionItem).id;
                //     }
                //   }
                //   const valueToValidate = child.condition.target ? await getRealValue(currValue, child.condition.target, inputs, remoteFuncExecutor) : currValue;
                //   if (valueToValidate) {
                //     const validRes = await validate(child.condition, valueToValidate as string | string[], inputs, remoteFuncExecutor);
                //     if (validRes !== undefined) {
                //       continue;
                //     }
                //   }
                // }
                // ++ totalSteps;
            }
        }
    }
    return { type: ui_1.InputResultType.sucess };
}
exports.traverse = traverse;
//# sourceMappingURL=visitor.js.map