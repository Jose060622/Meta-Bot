"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqlValidator = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const arm_sql_1 = require("@azure/arm-sql");
const chai = tslib_1.__importStar(require("chai"));
const tedious = tslib_1.__importStar(require("tedious"));
const mockAzureAccountProvider_1 = tslib_1.__importDefault(require("./mockAzureAccountProvider"));
const echoIpAddress = "https://api.ipify.org";
const localRule = "AllowLocal";
const azureSqlScope = "https://database.windows.net//.default";
const solutionPluginName = "solution";
const sqlPluginName = "fx-resource-azure-sql";
const identityPluginName = "fx-resource-identity";
const subscriptionKey = "subscriptionId";
const rgKey = "resourceGroupName";
const sqlKey = "sqlEndpoint";
const databaseKey = "databaseName";
const identityKey = "identity";
class SqlValidator {
    static async init(ctx) {
        console.log("Start to init validator for sql.");
        this.getConfig(ctx);
        const tokenCredential = await mockAzureAccountProvider_1.default.getAccountCredentialAsync();
        const sqlCredential = await mockAzureAccountProvider_1.default.getIdentityCredentialAsync();
        const sqlToken = await sqlCredential.getToken(azureSqlScope);
        this.accessToken = sqlToken.token;
        this.client = new arm_sql_1.SqlManagementClient(tokenCredential, this.subscriptionId);
        await this.addLocalFirewall();
        console.log("Successfully init validator for Azure AD app.");
    }
    static async validateSql() {
        const query = `select name as username from sys.database_principals where type not in ('A', 'G', 'R', 'X') and sid is not null and name = '${this.identity}';`;
        const res = await this.doQuery(this.accessToken, query);
        console.log(res.length);
        chai.expect(res.length).to.equal(1);
    }
    static getConfig(ctx) {
        this.subscriptionId = ctx[solutionPluginName][subscriptionKey];
        this.rg = ctx[solutionPluginName][rgKey];
        this.sqlEndpoint = ctx[sqlPluginName][sqlKey];
        this.databaseName = ctx[sqlPluginName][databaseKey];
        this.identity = ctx[identityPluginName][identityKey];
        this.sqlName = this.sqlEndpoint.substring(0, this.sqlEndpoint.indexOf("."));
    }
    static async addLocalFirewall() {
        const response = await axios_1.default.get(echoIpAddress);
        const localIp = response.data;
        const startIp = localIp.substring(0, localIp.lastIndexOf(".")) + ".1";
        const endIp = localIp.substring(0, localIp.lastIndexOf(".")) + ".255";
        const model = {
            startIpAddress: startIp,
            endIpAddress: endIp,
        };
        await this.client.firewallRules.createOrUpdate(this.rg, this.sqlName, localRule, model);
    }
    static async doQuery(token, cmd) {
        const config = {
            server: this.sqlEndpoint,
            authentication: {
                type: "azure-active-directory-access-token",
                options: {
                    token: token
                }
            }, options: {
                debug: {
                    packet: true,
                    data: true,
                    payload: true,
                    token: false,
                    log: true
                },
                rowCollectionOnDone: true,
                database: this.databaseName,
                encrypt: true,
                requestTimeout: 30000,
                connectTimeout: 30000,
            }
        };
        const connection = new tedious.Connection(config);
        return new Promise((resolve, reject) => {
            connection.on("connect", (err) => {
                if (err) {
                    reject(err);
                }
                const request = new tedious.Request(cmd, (err) => {
                    if (err) {
                        reject(err);
                    }
                });
                let res;
                request.on("doneInProc", function (rowCount, more, rows) {
                    res = rows;
                });
                request.on("requestCompleted", () => {
                    connection.close();
                    resolve(res);
                });
                request.on("error", (error) => {
                    reject(error);
                });
                connection.execSql(request);
            });
            connection.on("error", (err) => {
                reject(err);
            });
        });
    }
}
exports.SqlValidator = SqlValidator;
//# sourceMappingURL=sqlValidate.js.map